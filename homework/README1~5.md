## 每題說明

# 1(邏輯閘、布林邏輯)
## Not
* 完成方式: 參考教授設計
* 使用元件: `Nand`
* [使用GPT了解NOT的定義](https://chatgpt.com/share/691550d7-4680-8006-bf0f-97068832789e)
* ![NOT電路圖]()

## And
* 原創
* 使用元件: `Nand`, `Not`
* [使用GPT了解AND定義並且驗證AND程式](https://chatgpt.com/share/691552e8-5da8-8006-8027-4d807d528f22)
* ![AND電路圖](.jpg)

## Or
* 原創
* 使用元件: `Nand`, `Not`
* [使用GPT了解Or定義](https://chatgpt.com/share/691554d6-520c-8006-9a26-d24297488b23)
* ![OR電路圖](.jpg)

## XOr
* 使用GPT改過
* 使用元件: `And`, `Not`,`Or`
* [使用GPT了解XOr定義,驗證Xor程式](https://chatgpt.com/share/69160434-cd10-8006-af8e-43f9dc631272)
* ![XOr電路圖](.jpg)

## Mux
* Gemini幫改寫
* 使用元件: `And`, `Not`,`Or`
* 定義:資料輸入線(Data Inputs)等待被選取和傳輸的資料信號(一對多)
  選擇線(Select Lines)這些線路的組合值決定了哪一條資料輸入線會被選中並傳送到輸出。
  單一輸出線 (Single Output)這是被選中資料的最終傳輸點。
* [使用Gemini去了解MUX定義,幫我驗證改寫正確的hdl](https://gemini.google.com/share/7811ad91dbf4)
* ![Mux電路圖](.jpg)

## DMux
* Gemini幫改寫
* 使用元件: `Not`,`And`
* 組成:1 個輸入 (Input,D_{in}):這是要被傳輸的資料訊號。
  n條選擇線 (Select Lines)：這些線路決定了輸入訊號將被導向哪個輸出。
  2^n個輸出 (Outputs):這是資料可以傳輸到的所有可能的目的地。
* 工作原理:選擇線上的二進制值會被解碼。
  這個解碼後的地址會指定 `2^n` 個輸出中的唯一一個。
  輸入Data inputs上的訊號會被傳送到該被選中的輸出線上。
  所有未被選中的輸出線會保持為邏輯0(或高阻態)。
* [使用Gemini了解DMux組成和工作原理,驗證說明DMux程式](https://gemini.google.com/share/c7a6f528843d)
* ![DMux電路圖](.jpg)

## Not16
* 原創
* 使用元件: `Not`
* [使用Gemini了解Not16定義](https://gemini.google.com/share/286a3fdbeeff)
* ![DMux電路圖](.jpg)

## And16
* 原創
* 使用元件: `And`
* [使用GPT了解And16定義,驗證And16閘程式](https://chatgpt.com/share/693555db-9d40-800d-84f0-71103f958165)
* ![And16電路圖](.jpg)

## Or16
* 原創
* 使用元件: `Or`
* [使用GPT了解Or16定義,驗證Or16程式](https://chatgpt.com/s/m_68e6201355a48191a4bdab26f94d0fa6)
* ![Or16電路圖](.jpg)

## Mux16
* Gemini幫寫
* 使用元件: `Mux`
* 定義:
1. 有16個資料輸入信號或資料線
2. 有4個選擇輸入線決定了哪一個資料輸入會被選中(4個選擇位元可以產生，剛好對應16個輸入)。
3. 1個輸出:輸出端會呈現被選擇的那個輸入資料的邏輯值
4. 一個致能輸入(EN或G，但非所有MUX都有)用於控制整個MUX是否工作。當致能信號為高電位1或低電位0，電路才會工作，否則輸出會被禁用（通常為高阻態或固定輸出）
* [使用Gemini了解Mux16定義,驗證Mux16程式](https://gemini.google.com/share/b1af285d5095)
* ![Mux16電路圖](.jpg)

## Or8Way
* 原創
* 使用元件: `Or`
* 定義:有8個輸入端和1個輸出端的或門
* [使用Gemini了解Or8Way定義,驗證Or8Way程式](https://gemini.google.com/share/011a6d69ab3a)
* ![Or8Way電路圖](.jpg)

## Mux4Way16
* 參考答案修正
* 使用元件: `Mux16`
* 定義:負責從多個輸入中選擇一個輸出，有4個獨立的輸入信號，每一個輸入信號以及輸出信號都是16bit寬度的訊號線
* [使用Gemini了解Mux4Way16定義,驗證Mux4Way16閘程式並修正](https://gemini.google.com/share/b1628cac2b99)
* ![Mux4Way16電路圖](.jpg)

## Mux8Way16
* 使用Gemini幫寫
* 使用元件: `Mux16`
* 定義:是從8個16位元的輸入中，根據一個3位元的選擇訊號，選擇其中一個輸入作為 16 位元的輸出
* [使用Gemini了解Mux8Way16定義,幫寫Mux8Way16閘程式並驗證](https://gemini.google.com/share/64b8affca632)
* ![Mux8Way16電路圖](.jpg)

## DMux4Way
* Gemini幫寫
* 使用元件: `DMux`
* 定義:基礎的數位邏輯元件，將單一輸入訊號導向到四個輸出訊號中的其中一個
* 運作原理:接收一個輸入訊號(in)，根據2位元的選擇訊號(sel)，將該輸入訊號導向四個輸出通道(a, b, c, d)中的其中一個。其餘未被選中的通道則輸出
* [使用Gemini了解DMux4Way定義,驗證DMux4Way閘程式](https://gemini.google.com/share/9b45f767fe17)
* ![DMux4Way電路圖](.jpg)

## DMux8Way
* Gemini幫寫
* 使用元件: `DMux`,`DMux4Way`
* 定義:基礎的數位邏輯元件，將單一輸入訊號導向到八個輸出訊號中的其中一個
* 運作:DMux8Way的核心是為每個輸出out創建一個**[鎖定條件]**，這個條件只有在in為真(1)，並且選擇位元(sel)正確指向(k)時才會成立
* [使用Gemini了解DMux8Way定義,讓AI幫我寫DMux8Way閘程式並說明運作原理](https://gemini.google.com/share/5c5f17bec2fa)
* ![DMux8Way電路圖](.jpg)

# 2(布林運算)
## HalfAdder
* Gemini幫寫
* 使用元件: `XOr`,`AND`
* 定義:功能是將兩個單一位元(1bit)的數字相加，但它如果做多位數加法(例如第2個位元相加),前一位可能會有進位傳過來，但半加器的電路結構裡沒有設計接收Carry In的輸入端，所以它只能算[一半]的工作。
* 運作:接收兩個輸入位元，並產生兩個輸出位元，將[二進位加法]轉化為電子訊號的邏輯判斷。
* [使用Gemini了解HalfAdder定義,了解運作原理](https://gemini.google.com/share/5ebf45b13a4e)
* ![HalfAdder電路圖](.jpg)

## FullAdder
* Gemini幫寫
* 使用元件: `Or`,`HalfAdder`
* 定義:主要執行二進制的加法運算，全加器是一個將三個位元(Bits)相加的組合邏輯電路，全加器能夠處理來自低位數的[進位輸入]，可進行多位元(32bit或64bit)的加法運算
* 運作:接收三個輸入位元，並產生兩個輸出位元，將包含[前一位進位]在內的二進位加法轉化為電子訊號的邏輯判斷
* [使用Gemini了解FullAdder定義,了解運作原理，驗證FullAdder閘程式並做修正](https://gemini.google.com/share/c3361ddd4a6f)
* ![FullAdder電路圖](.jpg)

## Add16
* Gemini幫寫
* 使用元件: `FullAdder`
* 定義:將兩個16位元匯流排(Bus)數值相加的組合邏輯電路,由16個全加器串聯組成，透過處理內部從低位數傳遞上來的[連波進位]，來完成多位元的加法運算
* 運作:接收兩組16位元的輸入訊號，並產生一組16位元的輸出總和，將每一位元的加法運算結合[前一位的進位]轉化為電子訊號的邏輯判斷，最終輸出16位元的結果(經常忽略第15位產生的最終進位溢位)
* [使用Gemini了解Add16定義,了解連波進位](https://gemini.google.com/share/81d13cef2e8e)
* ![Add16電路圖](.jpg)

## Inc16
* 參考教授
* 使用元件: `Or`
* 定義:將16位元加法器簡化或改編而成，透過將輸入數值與固定數值1進行相加，來完成算術遞增運算
* 運作:接收一組16位元的輸入訊號，並產生一組數值加1後的16位元輸出。運作時，電路將輸入訊號的最低有效位與邏輯[1]進行加法，並透過內部的[連波進位]機制，將產生的進位訊號逐層向高位傳遞，最終輸出 16 位元的遞增結果[同樣忽略第 15 位產生之最終進位溢位]。
* [使用Gemini了解Inc16定義,驗證Inc16閘程式](https://gemini.google.com/share/99415129a7cf)
* ![Inc16電路圖](.jpg)

## ALU
* 使用Gemini幫寫
* 定義:算術電路(加法器)與邏輯電路(及閘、反閘)整合而成，接收特定的控制位元指令，來選擇並執行多種不同的算術或邏輯運算(如加法、減法、及運算、或非運算)。
* 運作:接收兩組16位元的輸入訊號（x、y以及一組6個控制位元，並產生一組經過計算後的16位元輸出，電路根據控制位元x或y進行預處理[歸零]或[位元反相]，將處理後的數值送入運算單元進行[算術加法]或[邏輯單元]運算，根據指令是否對運算結果進行[輸出反相]，最終輸出16位元的結果以及兩組狀態標誌（zr表示結果為零，ng表示結果的最高位元，直接看MSB是否為負）。
* [使用Gemini去了解ALU定義和運作，並且請AI幫我撰寫程式碼並說明](https://gemini.google.com/share/41296c3fe2ef)
* ![ALU電路圖](.jpg)

# 3(時序運算)
## Bit (暫存器)
* 使用Gemini幫寫
* 定義:DFF和Mux製成，作為基礎的記憶單元，接收特定的Load指令，來決定要新的數值還是原本數值
* 運作:接收一個1位元的數據輸入和一個1位元的載入load，並持續輸出當前儲存的1位元數值out。電路根據load進行選擇，若load為1，則多工器選擇將新的輸入值送入DFF，在下一個時脈週期更新儲存內容，若load為0，多工器則將當前的輸出值回授送入DFF，強行鎖定並保持原數值不變
* [使用Gemini去了解Bit定義和運作，了解DFF和時脈並且請AI幫我撰寫程式碼並說明](https://gemini.google.com/share/fdd2fc47eab1)
* ![Bit電路圖](.jpg)

## Register (16bit暫存器)
* 使用Gemini幫寫
* 定義:將16個1位元Bit並聯而成，作為處理16位元字組的基礎記憶單元。它接收單一的Load(控制位元)指令，用來同步控制所有內部位元的資料寫入或鎖存狀態
* 運作:接收一組16位元的數據輸入以及一個1位元的載入load(控制訊號)。若load為1，所有Bit單元同步寫入，將輸入的新數值更新至對應的儲存位置，若load為0，所有Bit單元則保持原有的16位元數值不變
* [使用Gemini去了解Register定義和運作，並且請AI幫我撰寫程式碼並驗證說明](https://gemini.google.com/share/577c2a9cb045)
* ![Register電路圖](.jpg)

## RAM8
* 使用Gemini幫寫
* 定義:將8個Register堆疊而成，有隨機存取的功能，接收位址與Load指令，用來針對特定的單一暫存器進行資料寫入或讀取狀態。
* 運作:接收一組16位元的數據輸入、一組3位元的位置(高3或低3)，以及一個1位元的載入load(控制訊號)，電路根據address將load訊號導向特定的暫存器，若load為1，僅有被位址選中的那一個暫存器會被寫入，將輸入的新數值更新至該位置，其餘7個暫存器維持原值，若load為0，所有暫存器則保持原有的16位元數值不變(僅執行讀取輸出)
* [使用Gemini去了解RAM8定義和運作，並且請AI幫我撰寫程式碼並驗證說明](https://gemini.google.com/share/b907c7a684c0)
 
## RAM64
* 使用Gemini幫寫
* 定義:將8個RAM8堆疊而成，接收6位元的位址(高3，低3)與Load指令，透過分層解碼的方式（先選群組、再選個體），針對特定的單一暫存器進行資料寫入或讀取狀態。
* 運作:接收一組16位元的數據輸入、一組6位元的位址(分為高3位與低3位，以及一個1位元的載入load控制訊號)，並持續輸出被位址選中之暫存器的16位元數值
* [使用Gemini去了解RAM64定義和運作，並且請AI幫我撰寫程式碼並驗證說明](https://gemini.google.com/share/bbba83488b4f)

## RAM512
* 使用Gemini幫寫
* 定義:將8個RAM64堆疊而成，接收9位元的位址(高3，低6)與Load指令，透過分層解碼的方式(先選群組、再選個體)，針對特定的單一暫存器進行資料寫入或讀取狀態。
* 運作:接收一組16位元的數據輸入、一組9位元的位址(高3位,低6位)，以及一個1位元的載入load，並持續輸出被位址選中之暫存器的16位元數值
* [使用Gemini去了解RAM512定義和運作，請AI說明位置解碼器並且請AI幫我撰寫程式碼並驗證說明](https://gemini.google.com/share/add56cd9e21f)

## RAM4K
* 使用Gemini幫寫
* 定義:將8個RAM512堆疊而成，接收12位元的位址(高3，低9)與Load指令，透過分層解碼的方式(先選群組、再選個體)，針對特定的單一暫存器進行資料寫入或讀取狀態。
* 運作:接收一組16位元的數據輸入、一組12位元的位址(高3，低9位)，以及一個1位元的載入load，並持續輸出被位址選中之暫存器的16位元數值
* [使用Gemini去了解RAM4K定義和運作，說明分層解碼並且，請AI幫我撰寫程式碼並驗證說明](https://gemini.google.com/share/0552f4e28bca)

## RAM16K
* 使用Gemini幫寫
* 定義:將4個RAM4K堆疊而成，接收14位元的位址(高2，低12)與Load指令，透過分層解碼的方式(先選群組、再選個體)，針對特定的單一暫存器進行資料寫入或讀取狀態。
* 運作:接收一組16位元的數據輸入、一組14位元的位址(高2，低12位)，以及一個1位元的載入load，並持續輸出被位址選中之暫存器的16位元數值。
* [使用Gemini去了解RAM16K定義和運作，並且請AI幫我撰寫程式碼並驗證說明](https://gemini.google.com/share/1076d95b0e20)

# 4(機器語言)
## fill.asm
* Gemini幫寫
* 定義:這是一個負責處理基本I/O控制的組合語言程式，整合了鍵盤偵測與螢幕繪圖的功能，利用無窮迴圈持續監聽記憶體映射鍵盤(KBD)的狀態。
* 運作:程式進入一個無窮監聽迴圈，將24576作為範圍，輸入數值不為0(代表有按鍵被按下)，螢幕畫面會被填滿，並啟動內層迴圈填滿螢幕區塊(位址16384至24575)，將所有畫面變為全黑，放開按鍵將所有像素暫存器更新為全白 (清除)，程式自動跳回開頭重新偵測鍵盤。
* [使用Gemini去了解fill定義和運作，並且請AI幫我撰寫程式碼並驗證說明](https://gemini.google.com/share/eba87491b874)

## Ｍult.asm
* Gemini幫寫
* 定義:這是一個關於組合語言程式，實作了軟體乘法功能，用以解決Hack硬體缺乏乘法指令。程式利用重複加法演算法，計算RAM[0]與RAM[1]的積，並將結果儲存於RAM[2]
* 運作:接收來自暫存器RAM[0]與RAM[1]的兩組數值輸入，以及一個用於儲存結果的RAM[2]，並持續將R0的數值累加至R2中。程式啟動後先將R2歸零，並以R1作為計數器，若R1大於0，則進入迴圈執行加法(將R0的值加入R2)並將R1減1，直到R1歸0時停止計算，程式最後自動進入一個無窮迴圈以保持結果數值穩定。
* [使用Gemini去了解Ｍult運作，並且請AI幫我撰寫程式碼並驗證說明](https://gemini.google.com/share/79cf99fd9b76)

# 5(計算機架構)
## Memory
* [參考教授](https://github.com/ccc114a/_co/blob/main/homework/5/Memory.hdl)
* 定義:將RAM16K(主記憶體)、Screen與Keyboard，將硬體設備視為記憶體位址，讓CPU能統一操控指令存取數據或周邊設備。
* 運作:接收一組16位元的數據輸入、一組15位元的位址，和一個1位元的載入load。電路根據位址範圍將訊號分流至三個不同位置
1. RAM16K(位址 0 - 16383)，若位址落在此範圍，數據與load訊號傳送至RAM16K進行讀寫
2. Screen(位址 16384 - 24575)，若位址落在此範圍，數據與load訊號傳送至Screen晶片，直接影響螢幕顯示內容
3. Keyboard(位址 24576)，若位址為24576，則讀取鍵盤當前按鍵的ASCII碼(資料無效)。
* [使用Gemini去了解Memory運作，並且請AI幫我撰寫程式碼並驗證說明](https://gemini.google .com/share/364327f497bb)

## CPU
* [參考教授](https://github.com/ccc114a/_co/blob/main/homework/5/CPU.hdl)
* 定義:這是一個執行指令與處理數據的核心單元，整合了ALU、暫存器與PC(程式計數器)。它管理數據的讀取、運算、寫入以及程式的跳轉流程
* 運作:CPU的運作嚴格遵循時脈(Clock)驅動，透過程式計數器(PC)、指令暫存器(IR)與控制單元(CU)的協作，週而復始地執行指令週期，其流程包含四個關鍵步驟:
1. 擷取(Fetch):CPU查看PC指向的記憶體位址，將該處的二進位指令讀取並存入指令暫存器(IR)，同時將PC更新(加 1)以指向下一條指令。
2. 解碼(Decode):控制單元(CU)分析IR中的操作碼(Opcode)，將其轉換為一組控制訊號，導通特定的電路路徑
3. 執行(Execute):算術邏輯單元(ALU)接收被導通的數據輸入，並依據控制訊號執行指定的運算(如加法、邏輯AND)。
4. 寫回(Write Back):將ALU計算出的電壓訊號結果透過匯流排傳回，並更新至目標暫存器中，完成單次指令執行。
* [使用Gemini去了解CPU運作，並且請AI幫我說明解答的程式碼](https://gemini.google.com/share/9c0936b801cf)

## Computer
* [參考教授](https://github.com/ccc114a/_co/blob/main/homework/5/Computer.hdl)
* 定義:透過系統匯流排將CPU、ROM32K(指令儲存器)和Memory(數據記憶體與設備映射)整合為一。它是一個硬體平台，能夠透過讀取不同的，將硬體邏輯轉化為可變的應用功能，實現從數學計算到圖形顯示與人機互動的各種任務。
* 運作:外部僅接收一個1位元的重置訊號，內部則在時脈的驅動下，進入永無止境的擷取-執行循環
1. 擷取(Fetch): CPU透過程式計數器的數值，向ROM32K請求特定位址的指令，ROM回傳對應的16位元指令代碼。
2. 處理(Process):CPU解碼並執行該指令，同時Memory讀取數據 (inM) 進行運算。
3. 副作用(Side Effects):根據運算結果，CPU可能更新內部暫存器，或輸出寫入訊號更新Memory。
4. 循環(Loop):完成後PC自動指向下一條指令，若reset為1，PC強制歸零，系統重新啟動。
* [使用Gemini去了解Computer定義和運作，並且請AI幫我說明解答的程式碼](https://gemini.google.com/share/1da2255dc724)
